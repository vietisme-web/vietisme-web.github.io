<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>Mini Terraria Step 1</title>
<style>
html, body {margin:0; padding:0; overflow:hidden; background:#87CEEB;}
canvas {display:block; background:#87CEEB;}
</style>
</head>
<body>
<canvas id="game"></canvas>
<script>
const canvas = document.getElementById('game');
const ctx = canvas.getContext('2d');
canvas.width = window.innerWidth;
canvas.height = window.innerHeight;

// map
const tileSize = 32, mapWidth = 100, mapHeight = 30;
let map = [];
for(let y=0;y<mapHeight;y++){
  let row=[];
  for(let x=0;x<mapWidth;x++){
    if(y>20) row.push('dirt');
    else if(y===20) row.push('grass');
    else row.push('air');
  }
  map.push(row);
}

// sảnh bắt đầu
let startHouse = {x:10,y:17,width:5,height:4};

// player humanoid pixel
let player = {
  x:startHouse.x*tileSize + tileSize*2,
  y:(startHouse.y-1)*tileSize,
  width:16,height:32,
  color:'#FF0000',
  vx:0,vy:0,speed:3,jump:8,onGround:false
};

// keys
let keys={};

// gravity
const gravity = 0.5;

// camera
let camX = 0, camY = 0;

// key listener
document.addEventListener('keydown',e=>keys[e.key.toLowerCase()]=true);
document.addEventListener('keyup',e=>keys[e.key.toLowerCase()]=false);

// update
function update(){
  // player movement
  if(keys['a']) player.vx=-player.speed;
  else if(keys['d']) player.vx=player.speed;
  else player.vx=0;

  // jump
  if(keys['w'] && player.onGround){ player.vy=-player.jump; player.onGround=false; }

  player.vy += gravity;
  player.x += player.vx;
  player.y += player.vy;

  // collision with map tiles
  player.onGround=false;
  let px = Math.floor(player.x/tileSize);
  let py = Math.floor(player.y/tileSize);
  for(let y=Math.max(0,py-1);y<Math.min(mapHeight,py+3);y++){
    for(let x=Math.max(0,px-1);x<Math.min(mapWidth,px+2);x++){
      if(map[y][x]!=='air'){
        let tileX = x*tileSize, tileY = y*tileSize;
        // simple collision
        if(player.x+player.width>tileX && player.x<tileX+tileSize && player.y+player.height>tileY && player.y<tileY+tileSize){
          // from top
          if(player.vy>0 && player.y+player.height-tileY<player.vy+1){ player.y=tileY-player.height; player.vy=0; player.onGround=true; }
          // from bottom
          else if(player.vy<0 && tileY+tileSize-player.y<Math.abs(player.vy)+1){ player.y=tileY+tileSize; player.vy=0; }
          // from sides
          else{ if(player.vx>0) player.x=tileX-player.width; else if(player.vx<0) player.x=tileX+tileSize; player.vx=0; }
        }
      }
    }
  }

  // camera follow
  camX = player.x - canvas.width/2 + player.width/2;
  camY = player.y - canvas.height/2 + player.height/2;
}

// draw
function draw(){
  ctx.clearRect(0,0,canvas.width,canvas.height);
  ctx.save();
  ctx.translate(-camX,-camY);

  // draw map
  for(let y=0;y<mapHeight;y++){
    for(let x=0;x<mapWidth;x++){
      if(map[y][x]==='dirt'){ctx.fillStyle='#8B4513'; ctx.fillRect(x*tileSize,y*tileSize,tileSize,tileSize);}
      else if(map[y][x]==='grass'){ctx.fillStyle='#00FF00'; ctx.fillRect(x*tileSize,y*tileSize,tileSize,tileSize);}
    }
  }

  // draw start house
  ctx.fillStyle='#654321';
  for(let y=0;y<startHouse.height;y++){
    for(let x=0;x<startHouse.width;x++){
      ctx.fillRect((startHouse.x+x)*tileSize,(startHouse.y-y)*tileSize,tileSize,tileSize);
    }
  }

  // draw player pixel humanoid
  ctx.fillStyle=player.color;
  // head
  ctx.fillRect(player.x,player.y,player.width,player.width);
  // body
  ctx.fillRect(player.x,player.y+player.width,player.width,player.height-player.width*1.5);
  // legs
  ctx.fillRect(player.x,player.y+player.height-8,player.width/2,8);
  ctx.fillRect(player.x+player.width/2,player.y+player.height-8,player.width/2,8);
  // arms
  ctx.fillRect(player.x-4,player.y+8,4,player.height/2);
  ctx.fillRect(player.x+player.width,player.y+8,4,player.height/2);

  ctx.restore();
}

// loop
function loop(){ update(); draw(); requestAnimationFrame(loop);}
loop();
</script>
</body>
</html>
<!-- copy đè index.html trước đó -->
<script>
// trees
let trees = [];
function generateTrees(){
  for(let i=0;i<10;i++){
    let x = 5 + Math.floor(Math.random()*50);
    let height = 3 + Math.floor(Math.random()*3);
    trees.push({x:x, y:19, height:height});
  }
}
generateTrees();

// chest
let chests = [{x:12, y:17, opened:false, items:['coin','potion']}];

// items on ground
let groundItems = [];

// skill effects
let skillEffects = [];

// key listener update
document.addEventListener('keydown', e=>{
  keys[e.key.toLowerCase()]=true;
  if(e.key.toLowerCase()==='e'){
    // open chest
    chests.forEach(c=>{
      if(!c.opened && Math.abs(player.x-c.x*tileSize)<32 && Math.abs(player.y-c.y*tileSize)<32){
        c.opened=true;
        c.items.forEach(it=>groundItems.push({x:c.x*tileSize+tileSize/2,y:c.y*tileSize,it:it,color:it==='coin'?'yellow':'cyan'}));
      }
    });
    // chop tree
    trees.forEach((t,idx)=>{
      if(Math.abs(player.x-t.x*tileSize)<32 && Math.abs(player.y-(t.y-t.height+1)*tileSize)<32){
        skillEffects.push({x:t.x*tileSize+tileSize/2, y:(t.y-t.height+1)*tileSize, life:20, color:'brown'});
        trees.splice(idx,1); // remove tree
      }
    });
  }
  // skill basic: melee swing
  if(e.key==='1'){
    skillEffects.push({x:player.x+player.width/2, y:player.y+player.height/2, life:20, color:'red'});
  }
});

document.addEventListener('keyup', e=>keys[e.key.toLowerCase()]=false);

// update skill & items
function updateStep2(){
  skillEffects.forEach((s,i)=>{s.life--; if(s.life<=0) skillEffects.splice(i,1);});
  // pick up items
  groundItems.forEach((it,idx)=>{
    if(Math.abs(player.x-it.x)<16 && Math.abs(player.y-it.y)<16){
      groundItems.splice(idx,1);
      console.log('Picked:', it.it);
    }
  });
}

// draw step 2
function drawStep2(){
  ctx.save();
  ctx.translate(-camX,-camY);

  // draw trees
  trees.forEach(t=>{
    ctx.fillStyle='brown';
    for(let h=0;h<t.height;h++) ctx.fillRect(t.x*tileSize,(t.y-h)*tileSize,tileSize,tileSize);
    ctx.fillStyle='green';
    ctx.fillRect(t.x*tileSize,(t.y-t.height)*tileSize,tileSize,tileSize);
  });

  // draw chests
  chests.forEach(c=>{
    ctx.fillStyle=c.opened?'yellow':'orange';
    ctx.fillRect(c.x*tileSize,c.y*tileSize,tileSize,tileSize);
  });

  // draw items on ground
  groundItems.forEach(it=>{
    ctx.fillStyle=it.color;
    ctx.fillRect(it.x-8,it.y-8,16,16);
  });

  // draw skill effects
  skillEffects.forEach(s=>{
    ctx.fillStyle=s.color;
    ctx.globalAlpha = s.life/20;
    ctx.fillRect(s.x-8,s.y-8,16,16);
    ctx.globalAlpha=1;
  });

  ctx.restore();
}

// integrate into loop
function loopStep2(){
  update(); // step1 physics
  updateStep2(); // step2 items/skill
  draw();
  drawStep2();
  requestAnimationFrame(loopStep2);
}
loopStep2();
</script>
<script>
// monsters
let monsters = [];
function spawnMonsters(n){
  for(let i=0;i<n;i++){
    monsters.push({x:Math.random()*mapWidth*tileSize,y:18*tileSize+Math.random()*50,width:24,height:24,color:'green',vx:(Math.random()-0.5)*1,vy:0,hp:20});
  }
}
spawnMonsters(10);

// boss mini
let bosses = [{x:30*tileSize, y:18*tileSize,width:48,height:48,color:'purple',hp:100}];

// pets
let pets = [{x:player.x-20, y:player.y, width:16,height:16,color:'orange',damage:5}];

// update monsters/boss/pets
function updateStep3(){
  monsters.forEach((m,idx)=>{
    // simple AI: move toward player
    let dx = player.x - m.x;
    m.vx = dx*0.01;
    m.x += m.vx;
    // collision with player
    if(Math.abs(player.x-m.x)<20 && Math.abs(player.y-m.y)<20) player.hp -= 0.1;
    if(m.hp<=0) monsters.splice(idx,1);
  });

  bosses.forEach((b,idx)=>{
    let dx = player.x - b.x;
    b.x += dx*0.02;
    if(Math.abs(player.x-b.x)<30 && Math.abs(player.y-b.y)<30) player.hp -= 0.5;
    if(b.hp<=0) bosses.splice(idx,1);
  });

  // pets follow player
  pets.forEach(p=>{
    let dx = player.x - p.x;
    p.x += dx*0.05;
    // attack nearest monster
    let target = monsters[0];
    if(target){
      let tdx = target.x - p.x;
      p.x += tdx*0.05;
      if(Math.abs(target.x-p.x)<10){target.hp -= p.damage; skillEffects.push({x:target.x, y:target.y, life:15, color:'orange'});}
    }
  });
}

// draw monsters/boss/pets
function drawStep3(){
  ctx.save();
  ctx.translate(-camX,-camY);
  monsters.forEach(m=>{ctx.fillStyle=m.color; ctx.fillRect(m.x,m.y,m.width,m.height);});
  bosses.forEach(b=>{ctx.fillStyle=b.color; ctx.fillRect(b.x,b.y,b.width,b.height);});
  pets.forEach(p=>{ctx.fillStyle=p.color; ctx.fillRect(p.x,p.y,p.width,p.height);});
  ctx.restore();
}

// integrate into loop
function loopStep3(){
  update(); // step1 physics
  updateStep2(); // step2 items/skill
  updateStep3(); // step3 monsters/boss/pets
  draw();
  drawStep2();
  drawStep3();
  requestAnimationFrame(loopStep3);
}
loopStep3();
</script>
<script>
// map mở rộng
for(let y=21;y<mapHeight;y++){
  for(let x=0;x<mapWidth;x++){
    if(map[y][x]==='air'){
      let r=Math.random();
      if(r<0.02) map[y][x]='ore';
      else if(r<0.05) map[y][x]='rock';
    }
  }
}

// day/night
let time=0;
function updateDayNight(){
  time+=0.01;
}

// skill: magic fireball + arrow
document.addEventListener('keydown',e=>{
  if(e.key==='2'){ // fireball
    skillEffects.push({x:player.x,y:player.y,vx:5,vy:0,life:40,color:'orange',type:'fireball',trail:[]});
  }
  if(e.key==='3'){ // arrow
    skillEffects.push({x:player.x,y:player.y,vx:7,vy:0,life:30,color:'gray',type:'arrow',trail:[]});
  }
});

// update skill projectiles
function updateSkillEffects(){
  skillEffects.forEach((s,i)=>{
    s.x += s.vx || 0;
    s.y += s.vy || 0;
    s.life--;
    if(s.trail) s.trail.push({x:s.x,y:s.y});
    if(s.trail && s.trail.length>10) s.trail.shift();
    // collision with monsters/boss
    monsters.forEach((m,mi)=>{
      if(Math.abs(m.x-s.x)<20 && Math.abs(m.y-s.y)<20){ m.hp-=5; skillEffects.push({x:m.x,y:m.y,life:10,color:'red'});}
    });
    bosses.forEach((b,bi)=>{
      if(Math.abs(b.x-s.x)<25 && Math.abs(b.y-s.y)<25){ b.hp-=5; skillEffects.push({x:b.x,y:b.y,life:10,color:'red'});}
    });
    if(s.life<=0) skillEffects.splice(i,1);
  });
}

// draw skill effects with trail
function drawSkillEffects(){
  ctx.save();
  ctx.translate(-camX,-camY);
  skillEffects.forEach(s=>{
    if(s.trail){
      ctx.strokeStyle=s.color;
      ctx.lineWidth=2;
      ctx.beginPath();
      ctx.moveTo(s.trail[0].x,s.trail[0].y);
      for(let i=1;i<s.trail.length;i++) ctx.lineTo(s.trail[i].x,s.trail[i].y);
      ctx.stroke();
    }
    ctx.fillStyle=s.color;
    ctx.globalAlpha = 0.8;
    ctx.fillRect(s.x-4,s.y-4,8,8);
    ctx.globalAlpha=1;
  });
  ctx.restore();
}

// integrate into loop
function loopStep45(){
  update(); // physics
  updateStep2(); // items/chest
  updateStep3(); // monsters/boss/pets
  updateDayNight();
  updateSkillEffects();
  draw();
  drawStep2();
  drawStep3();
  drawSkillEffects();
  // overlay day/night
  ctx.fillStyle='rgba(0,0,50,'+Math.sin(time)*0.3+')';
  ctx.fillRect(0,0,canvas.width,canvas.height);
  requestAnimationFrame(loopStep45);
}
loopStep45();
</script>
<script>
// biome map generation
function generateBiomes(){
  for(let y=21;y<mapHeight;y++){
    for(let x=0;x<mapWidth;x++){
      let r=Math.random();
      if(r<0.02) map[y][x]='ore';
      else if(r<0.05) map[y][x]='rock';
      else if(y>22 && Math.random()<0.01) map[y][x]='lava';
    }
  }
}
generateBiomes();

// multiple bosses
bosses.push({x:80*tileSize,y:18*tileSize,width:64,height:64,color:'darkred',hp:300,skillTimer:0});

// advanced skill effects
document.addEventListener('keydown',e=>{
  if(e.key==='4'){ // lightning skill
    for(let i=0;i<5;i++){
      skillEffects.push({x:player.x,y:player.y,vx:0,vy:5+i,life:30,color:'cyan',type:'lightning',trail:[]});
    }
  }
});

// update advanced skill effects
function updateSkillEffectsAdvanced(){
  skillEffects.forEach((s,i)=>{
    s.x += s.vx || 0; s.y += s.vy || 0;
    s.life--;
    if(s.trail) s.trail.push({x:s.x,y:s.y}); if(s.trail && s.trail.length>12) s.trail.shift();
    monsters.forEach((m,mi)=>{ if(Math.abs(m.x-s.x)<20 && Math.abs(m.y-s.y)<20){ m.hp-=10; skillEffects.push({x:m.x,y:m.y,life:12,color:s.color});}});
    bosses.forEach((b,bi)=>{ if(Math.abs(b.x-s.x)<30 && Math.abs(b.y-s.y)<30){ b.hp-=10; skillEffects.push({x:b.x,y:b.y,life:12,color:s.color});}});
    if(s.life<=0) skillEffects.splice(i,1);
  });
}

// advanced pet AI
pets.forEach(p=>{
  let nearest = monsters[0] || bosses[0];
  if(nearest){
    let dx=nearest.x-p.x;
    p.x += dx*0.05;
    if(Math.abs(dx)<10){ nearest.hp -= p.damage; skillEffects.push({x:nearest.x,y:nearest.y,life:10,color:'orange'});}
  }
});

// crafting system (basic)
let craftingTable = {
  'wood_sword':['wood','wood'],
  'magic_staff':['wood','potion']
};
function craft(item,inventory){
  if(craftingTable[item]){
    let can=true;
    craftingTable[item].forEach(i=>{if(!inventory.includes(i)) can=false;});
    if(can){ craftingTable[item].forEach(i=>{ let idx=inventory.indexOf(i); if(idx>-1) inventory.splice(idx,1);}); inventory.push(item); console.log('Crafted:',item); }
  }
}

// draw overlay lighting/day/night
ctx.fillStyle='rgba(0,0,50,'+Math.sin(time)*0.3+')';
ctx.fillRect(0,0,canvas.width,canvas.height);

// loop final integration
function loopFinal(){
  update(); updateStep2(); updateStep3(); updateDayNight(); updateSkillEffects(); updateSkillEffectsAdvanced();
  draw(); drawStep2(); drawStep3(); drawSkillEffects();
  requestAnimationFrame(loopFinal);
}
loopFinal();
</script>
