<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>Pixel Survival Step 2</title>
<style>
  html, body { margin: 0; padding: 0; overflow: hidden; background: #87CEEB; }
  canvas { display: block; background: #87CEEB; }
</style>
</head>
<body>
<canvas id="game"></canvas>
<script>
const canvas = document.getElementById('game');
const ctx = canvas.getContext('2d');
canvas.width = window.innerWidth;
canvas.height = window.innerHeight;

// player
let player = { x: canvas.width/2, y: canvas.height/2, size: 32, speed: 3, color: 'red' };

// keys
let keys = {};

// clouds
let clouds = [];
for(let i=0;i<5;i++){
  clouds.push({x:Math.random()*canvas.width, y:Math.random()*100, w:100, h:50, speed:0.2+Math.random()*0.3});
}

// monsters
let monsters = [];
for(let i=0;i<5;i++){
  monsters.push({x:Math.random()*canvas.width, y:Math.random()*canvas.height, size:32, color:'green', hp:100});
}

// chests
let chests = [];
for(let i=0;i<3;i++){
  chests.push({x:Math.random()*canvas.width, y:Math.random()*canvas.height, size:32, opened:false});
}

// pets
let pets = [];
for(let i=0;i<2;i++){
  pets.push({x:player.x+Math.random()*50, y:player.y+Math.random()*50, size:16, color:'orange'});
}

// key listener
document.addEventListener('keydown', e=> keys[e.key.toLowerCase()] = true);
document.addEventListener('keyup', e=> keys[e.key.toLowerCase()] = false);

// update
function update(){
  // player movement
  if(keys['w']) player.y -= player.speed;
  if(keys['s']) player.y += player.speed;
  if(keys['a']) player.x -= player.speed;
  if(keys['d']) player.x += player.speed;

  // clouds
  clouds.forEach(c=>{
    c.x += c.speed;
    if(c.x>canvas.width) c.x=-c.w;
  });

  // pets follow player
  pets.forEach(p=>{
    let dx = player.x - p.x;
    let dy = player.y - p.y;
    let dist = Math.sqrt(dx*dx + dy*dy);
    if(dist>20){
      p.x += dx*0.05;
      p.y += dy*0.05;
    }
  });
}

// draw
function draw(){
  ctx.fillStyle = '#87CEEB';
  ctx.fillRect(0,0,canvas.width,canvas.height);

  // clouds
  clouds.forEach(c=>{
    ctx.fillStyle = 'white';
    ctx.beginPath();
    ctx.ellipse(c.x,c.y,c.w,c.h,0,0,Math.PI*2);
    ctx.fill();
  });

  // monsters
  monsters.forEach(m=>{
    ctx.fillStyle = m.color;
    ctx.fillRect(m.x-m.size/2, m.y-m.size/2, m.size, m.size);
  });

  // chests
  chests.forEach(ch=>{
    ctx.fillStyle = ch.opened ? 'yellow' : 'brown';
    ctx.fillRect(ch.x-ch.size/2, ch.y-ch.size/2, ch.size, ch.size);
  });

  // pets
  pets.forEach(p=>{
    ctx.fillStyle = p.color;
    ctx.fillRect(p.x-p.size/2, p.y-p.size/2, p.size, p.size);
  });

  // player
  ctx.fillStyle = player.color;
  ctx.fillRect(player.x-player.size/2, player.y-player.size/2, player.size, player.size);
}

// main loop
function loop(){
  update();
  draw();
  requestAnimationFrame(loop);
}

loop();
</script>
</body>
</html>
<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>Pixel Survival Step 1</title>
<style>
  html, body { margin: 0; padding: 0; overflow: hidden; background: #87CEEB; }
  canvas { display: block; background: #87CEEB; }
</style>
</head>
<body>
<canvas id="game"></canvas>
<script>
const canvas = document.getElementById('game');
const ctx = canvas.getContext('2d');
canvas.width = window.innerWidth;
canvas.height = window.innerHeight;

// biến player
let player = { x: canvas.width/2, y: canvas.height/2, size: 32, speed: 3, color: 'red' };

// lưu trạng thái phím
let keys = {};

// clouds
let clouds = [];
for(let i=0;i<5;i++){
  clouds.push({x:Math.random()*canvas.width, y:Math.random()*100, w:100, h:50, speed:0.2+Math.random()*0.3});
}

// lắng nghe phím
document.addEventListener('keydown', e=> keys[e.key.toLowerCase()] = true);
document.addEventListener('keyup', e=> keys[e.key.toLowerCase()] = false);

// update logic
function update(){
  if(keys['w']) player.y -= player.speed;
  if(keys['s']) player.y += player.speed;
  if(keys['a']) player.x -= player.speed;
  if(keys['d']) player.x += player.speed;

  clouds.forEach(c=>{
    c.x += c.speed;
    if(c.x>canvas.width) c.x=-c.w;
  });
}

// vẽ mọi thứ
function draw(){
  ctx.fillStyle = '#87CEEB';
  ctx.fillRect(0,0,canvas.width,canvas.height);

  clouds.forEach(c=>{
    ctx.fillStyle = 'white';
    ctx.beginPath();
    ctx.ellipse(c.x,c.y,c.w,c.h,0,0,Math.PI*2);
    ctx.fill();
  });

  ctx.fillStyle = player.color;
  ctx.fillRect(player.x-player.size/2, player.y-player.size/2, player.size, player.size);
}

// main loop
function loop(){
  update();
  draw();
  requestAnimationFrame(loop);
}

loop();
</script>
</body>
</html>
<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>Pixel Survival Step 3</title>
<style>
  html, body { margin: 0; padding: 0; overflow: hidden; background: #87CEEB; }
  canvas { display: block; background: #87CEEB; }
</style>
</head>
<body>
<canvas id="game"></canvas>
<script>
const canvas = document.getElementById('game');
const ctx = canvas.getContext('2d');
canvas.width = window.innerWidth;
canvas.height = window.innerHeight;

// player
let player = { x: canvas.width/2, y: canvas.height/2, size: 32, speed: 3, color: 'red' };

// keys
let keys = {};

// clouds
let clouds = [];
for(let i=0;i<5;i++){
  clouds.push({x:Math.random()*canvas.width, y:Math.random()*100, w:100, h:50, speed:0.2+Math.random()*0.3});
}

// monsters
let monsters = [];
for(let i=0;i<5;i++){
  monsters.push({x:Math.random()*canvas.width, y:Math.random()*canvas.height, size:32, color:'green', hp:100});
}

// chests
let chests = [];
for(let i=0;i<3;i++){
  chests.push({x:Math.random()*canvas.width, y:Math.random()*canvas.height, size:32, opened:false});
}

// pets
let pets = [];
for(let i=0;i<2;i++){
  pets.push({x:player.x+Math.random()*50, y:player.y+Math.random()*50, size:16, color:'orange'});
}

// inventory
let inventoryOpen = false;

// effects (skill)
let effects = [];

// key listener
document.addEventListener('keydown', e=> {
  keys[e.key.toLowerCase()] = true;

  // toggle inventory
  if(e.key.toLowerCase() === 'i') inventoryOpen = !inventoryOpen;

  // open chest
  if(e.key.toLowerCase() === 'e'){
    chests.forEach(ch=>{
      let dx = player.x - ch.x;
      let dy = player.y - ch.y;
      if(Math.sqrt(dx*dx+dy*dy) < 50) ch.opened = true;
    });
  }

  // skills 1-4
  if(['1','2','3','4'].includes(e.key)){
    effects.push({x:player.x, y:player.y, type:'skill'+e.key, frame:0});
  }
});

document.addEventListener('keyup', e=> keys[e.key.toLowerCase()] = false);

// update
function update(){
  // player movement
  if(keys['w']) player.y -= player.speed;
  if(keys['s']) player.y += player.speed;
  if(keys['a']) player.x -= player.speed;
  if(keys['d']) player.x += player.speed;

  // clouds
  clouds.forEach(c=>{
    c.x += c.speed;
    if(c.x>canvas.width) c.x=-c.w;
  });

  // pets follow player
  pets.forEach(p=>{
    let dx = player.x - p.x;
    let dy = player.y - p.y;
    let dist = Math.sqrt(dx*dx + dy*dy);
    if(dist>20){
      p.x += dx*0.05;
      p.y += dy*0.05;
    }
  });

  // update effects
  effects.forEach(e=> e.frame++);
  effects = effects.filter(e=> e.frame < 30);
}

// draw
function draw(){
  ctx.fillStyle = '#87CEEB';
  ctx.fillRect(0,0,canvas.width,canvas.height);

  // clouds
  clouds.forEach(c=>{
    ctx.fillStyle = 'white';
    ctx.beginPath();
    ctx.ellipse(c.x,c.y,c.w,c.h,0,0,Math.PI*2);
    ctx.fill();
  });

  // monsters
  monsters.forEach(m=>{
    ctx.fillStyle = m.color;
    ctx.fillRect(m.x-m.size/2, m.y-m.size/2, m.size, m.size);
  });

  // chests
  chests.forEach(ch=>{
    ctx.fillStyle = ch.opened ? 'yellow' : 'brown';
    ctx.fillRect(ch.x-ch.size/2, ch.y-ch.size/2, ch.size, ch.size);
  });

  // pets
  pets.forEach(p=>{
    ctx.fillStyle = p.color;
    ctx.fillRect(p.x-p.size/2, p.y-p.size/2, p.size, p.size);
  });

  // player
  ctx.fillStyle = player.color;
  ctx.fillRect(player.x-player.size/2, player.y-player.size/2, player.size, player.size);

  // effects (skills)
  effects.forEach(e=>{
    ctx.fillStyle = e.type==='skill1'?'cyan':'magenta';
    ctx.beginPath();
    ctx.arc(e.x, e.y, 10+e.frame, 0, Math.PI*2);
    ctx.fill();
  });

  // inventory
  if(inventoryOpen){
    ctx.fillStyle='rgba(0,0,0,0.5)';
    ctx.fillRect(50,50,200,300);
    ctx.fillStyle='white';
    ctx.fillText('Inventory', 100, 70);
  }
}

// main loop
function loop(){
  update();
  draw();
  requestAnimationFrame(loop);
}

loop();
</script>
</body>
</html>
<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>Pixel Survival Step 4</title>
<style>
  html, body { margin:0; padding:0; overflow:hidden; background:#87CEEB; }
  canvas { display:block; background:#87CEEB; }
</style>
</head>
<body>
<canvas id="game"></canvas>
<script>
const canvas = document.getElementById('game');
const ctx = canvas.getContext('2d');
canvas.width = window.innerWidth;
canvas.height = window.innerHeight;

// player
let player = { x: canvas.width/2, y: canvas.height/2, size:32, speed:3, color:'red' };

// keys
let keys = {};

// clouds
let clouds = [];
for(let i=0;i<5;i++){
  clouds.push({x:Math.random()*canvas.width, y:Math.random()*100, w:100, h:50, speed:0.2+Math.random()*0.3});
}

// monsters
let monsters = [];
for(let i=0;i<5;i++){
  monsters.push({x:Math.random()*canvas.width, y:Math.random()*canvas.height, size:32, color:'green', hp:100});
}

// chests
let chests = [];
for(let i=0;i<3;i++){
  chests.push({x:Math.random()*canvas.width, y:Math.random()*canvas.height, size:32, opened:false});
}

// pets
let pets = [];
for(let i=0;i<2;i++){
  pets.push({x:player.x+Math.random()*50, y:player.y+Math.random()*50, size:16, color:'orange'});
}

// inventory
let inventoryOpen = false;

// particle effects
let effects = [];

// key listener
document.addEventListener('keydown', e=>{
  keys[e.key.toLowerCase()] = true;

  if(e.key.toLowerCase() === 'i') inventoryOpen = !inventoryOpen;

  if(e.key.toLowerCase() === 'e'){
    chests.forEach(ch=>{
      let dx = player.x - ch.x;
      let dy = player.y - ch.y;
      if(Math.sqrt(dx*dx+dy*dy)<50) ch.opened=true;
    });
  }

  if(['1','2','3','4'].includes(e.key)){
    // tạo particle skill
    for(let i=0;i<20;i++){
      let angle = Math.random()*Math.PI*2;
      let speed = Math.random()*3+1;
      effects.push({
        x:player.x,
        y:player.y,
        vx:Math.cos(angle)*speed,
        vy:Math.sin(angle)*speed,
        radius:5,
        color: e.key==='1'?'cyan': e.key==='2'?'magenta': e.key==='3'?'yellow':'lime',
        life:30
      });
    }
  }
});
document.addEventListener('keyup', e=> keys[e.key.toLowerCase()] = false);

// update
function update(){
  if(keys['w']) player.y -= player.speed;
  if(keys['s']) player.y += player.speed;
  if(keys['a']) player.x -= player.speed;
  if(keys['d']) player.x += player.speed;

  clouds.forEach(c=>{
    c.x += c.speed;
    if(c.x>canvas.width) c.x=-c.w;
  });

  pets.forEach(p=>{
    let dx = player.x - p.x;
    let dy = player.y - p.y;
    let dist = Math.sqrt(dx*dx+dy*dy);
    if(dist>20){
      p.x += dx*0.05;
      p.y += dy*0.05;
    }
  });

  effects.forEach(e=>{
    e.x += e.vx;
    e.y += e.vy;
    e.radius *= 0.95;
    e.life--;
  });
  effects = effects.filter(e=>e.life>0);
}

// draw
function draw(){
  ctx.clearRect(0,0,canvas.width,canvas.height);

  // background
  ctx.fillStyle='#87CEEB';
  ctx.fillRect(0,0,canvas.width,canvas.height);

  // clouds
  clouds.forEach(c=>{
    ctx.fillStyle='white';
    ctx.beginPath();
    ctx.ellipse(c.x,c.y,c.w,c.h,0,0,Math.PI*2);
    ctx.fill();
  });

  // monsters
  monsters.forEach(m=>{
    ctx.fillStyle=m.color;
    ctx.fillRect(m.x-m.size/2, m.y-m.size/2, m.size, m.size);
  });

  // chests
  chests.forEach(ch=>{
    ctx.fillStyle = ch.opened?'yellow':'brown';
    ctx.fillRect(ch.x-ch.size/2, ch.y-ch.size/2, ch.size, ch.size);
  });

  // pets
  pets.forEach(p=>{
    ctx.fillStyle=p.color;
    ctx.fillRect(p.x-p.size/2, p.y-p.size/2, p.size, p.size);
  });

  // player glow
  ctx.save();
  ctx.shadowColor='white';
  ctx.shadowBlur=20;
  ctx.fillStyle=player.color;
  ctx.fillRect(player.x-player.size/2, player.y-player.size/2, player.size, player.size);
  ctx.restore();

  // skill particles
  effects.forEach(e=>{
    ctx.save();
    ctx.globalAlpha = e.life/30;
    ctx.fillStyle = e.color;
    ctx.beginPath();
    ctx.arc(e.x,e.y,e.radius,0,Math.PI*2);
    ctx.fill();
    ctx.restore();
  });

  // inventory
  if(inventoryOpen){
    ctx.fillStyle='rgba(0,0,0,0.5)';
    ctx.fillRect(50,50,200,300);
    ctx.fillStyle='white';
    ctx.fillText('Inventory',100,70);
  }
}

// loop
function loop(){
  update();
  draw();
  requestAnimationFrame(loop);
}
loop();
</script>
</body>
</html>
<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>Pixel Survival Step 5</title>
<style>
  html, body { margin:0; padding:0; overflow:hidden; background:#87CEEB; }
  canvas { display:block; background:#87CEEB; }
</style>
</head>
<body>
<canvas id="game"></canvas>
<script>
const canvas = document.getElementById('game');
const ctx = canvas.getContext('2d');
canvas.width = window.innerWidth;
canvas.height = window.innerHeight;

// player
let player = { x:500, y:500, size:32, speed:3, color:'red' };

// keys
let keys = {};

// map tiles
const tileSize = 64;
const mapWidth = 30;
const mapHeight = 20;

// generate map (random ground/water)
let map = [];
for(let y=0;y<mapHeight;y++){
  let row = [];
  for(let x=0;x<mapWidth;x++){
    row.push(Math.random()<0.1?'water':'grass');
  }
  map.push(row);
}

// clouds
let clouds = [];
for(let i=0;i<5;i++) clouds.push({x:Math.random()*canvas.width, y:Math.random()*100, w:100, h:50, speed:0.2+Math.random()*0.3});

// monsters
let monsters = [];
for(let i=0;i<10;i++){
  monsters.push({
    x:Math.random()*mapWidth*tileSize,
    y:Math.random()*mapHeight*tileSize,
    size:32, color:'green', hp:100,
    vx:(Math.random()-0.5)*2, vy:(Math.random()-0.5)*2
  });
}

// chests
let chests = [];
for(let i=0;i<10;i++){
  chests.push({
    x:Math.random()*mapWidth*tileSize,
    y:Math.random()*mapHeight*tileSize,
    size:32, opened:false
  });
}

// pets
let pets = [];
for(let i=0;i<2;i++) pets.push({x:player.x+Math.random()*50, y:player.y+Math.random()*50, size:16, color:'orange'});

// inventory
let inventoryOpen = false;

// particle effects
let effects = [];

// key listener
document.addEventListener('keydown', e=>{
  keys[e.key.toLowerCase()] = true;
  if(e.key.toLowerCase() === 'i') inventoryOpen = !inventoryOpen;

  if(e.key.toLowerCase() === 'e'){
    chests.forEach(ch=>{
      let dx = player.x - ch.x;
      let dy = player.y - ch.y;
      if(Math.sqrt(dx*dx+dy*dy)<50) ch.opened=true;
    });
  }

  if(['1','2','3','4'].includes(e.key)){
    for(let i=0;i<20;i++){
      let angle = Math.random()*Math.PI*2;
      let speed = Math.random()*3+1;
      effects.push({
        x:player.x, y:player.y,
        vx:Math.cos(angle)*speed,
        vy:Math.sin(angle)*speed,
        radius:5,
        color: e.key==='1'?'cyan': e.key==='2'?'magenta': e.key==='3'?'yellow':'lime',
        life:30
      });
    }
  }
});
document.addEventListener('keyup', e=> keys[e.key.toLowerCase()] = false);

// update
function update(){
  // player movement
  if(keys['w']) player.y -= player.speed;
  if(keys['s']) player.y += player.speed;
  if(keys['a']) player.x -= player.speed;
  if(keys['d']) player.x += player.speed;

  // clouds
  clouds.forEach(c=>{
    c.x += c.speed;
    if(c.x>canvas.width) c.x=-c.w;
  });

  // pets follow player
  pets.forEach(p=>{
    let dx = player.x - p.x;
    let dy = player.y - p.y;
    let dist = Math.sqrt(dx*dx+dy*dy);
    if(dist>20){
      p.x += dx*0.05;
      p.y += dy*0.05;
    }
  });

  // monsters AI move
  monsters.forEach(m=>{
    m.x += m.vx;
    m.y += m.vy;
    if(m.x<0 || m.x>mapWidth*tileSize) m.vx*=-1;
    if(m.y<0 || m.y>mapHeight*tileSize) m.vy*=-1;
  });

  // effects
  effects.forEach(e=>{
    e.x += e.vx;
    e.y += e.vy;
    e.radius *= 0.95;
    e.life--;
  });
  effects = effects.filter(e=>e.life>0);
}

// draw
function draw(){
  ctx.clearRect(0,0,canvas.width,canvas.height);

  // draw map tiles
  for(let y=0;y<mapHeight;y++){
    for(let x=0;x<mapWidth;x++){
      ctx.fillStyle = map[y][x]==='grass'?'#7cfc00':'#1e90ff';
      ctx.fillRect(x*tileSize, y*tileSize, tileSize, tileSize);
    }
  }

  // clouds
  clouds.forEach(c=>{
    ctx.fillStyle='white';
    ctx.beginPath();
    ctx.ellipse(c.x,c.y,c.w,c.h,0,0,Math.PI*2);
    ctx.fill();
  });

  // monsters
  monsters.forEach(m=>{
    ctx.fillStyle=m.color;
    ctx.fillRect(m.x-m.size/2, m.y-m.size/2, m.size, m.size);
  });

  // chests
  chests.forEach(ch=>{
    ctx.fillStyle=ch.opened?'yellow':'brown';
    ctx.fillRect(ch.x-ch.size/2, ch.y-ch.size/2, ch.size, ch.size);
  });

  // pets
  pets.forEach(p=>{
    ctx.fillStyle=p.color;
    ctx.fillRect(p.x-p.size/2, p.y-p.size/2, p.size, p.size);
  });

  // player glow
  ctx.save();
  ctx.shadowColor='white';
  ctx.shadowBlur=20;
  ctx.fillStyle=player.color;
  ctx.fillRect(player.x-player.size/2, player.y-player.size/2, player.size, player.size);
  ctx.restore();

  // particle effects
  effects.forEach(e=>{
    ctx.save();
    ctx.globalAlpha = e.life/30;
    ctx.fillStyle = e.color;
    ctx.beginPath();
    ctx.arc(e.x,e.y,e.radius,0,Math.PI*2);
    ctx.fill();
    ctx.restore();
  });

  // inventory
  if(inventoryOpen){
    ctx.fillStyle='rgba(0,0,0,0.5)';
    ctx.fillRect(50,50,200,300);
    ctx.fillStyle='white';
    ctx.fillText('Inventory',100,70);
  }
}

// loop
function loop(){
  update();
  draw();
  requestAnimationFrame(loop);
}
loop();
</script>
</body>
</html>
<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>Pixel Survival Step 6</title>
<style>
  html, body { margin:0; padding:0; overflow:hidden; background:#87CEEB; }
  canvas { display:block; background:#87CEEB; }
</style>
</head>
<body>
<canvas id="game"></canvas>
<script>
const canvas = document.getElementById('game');
const ctx = canvas.getContext('2d');
canvas.width = window.innerWidth;
canvas.height = window.innerHeight;

// player
let player = { x:500, y:500, size:32, speed:3, color:'red', weapon:'sword' };

// keys
let keys = {};

// map tiles
const tileSize = 64;
const mapWidth = 30;
const mapHeight = 20;

// map
let map = [];
for(let y=0;y<mapHeight;y++){
  let row = [];
  for(let x=0;x<mapWidth;x++){
    row.push(Math.random()<0.1?'water':'grass');
  }
  map.push(row);
}

// clouds
let clouds = [];
for(let i=0;i<5;i++) clouds.push({x:Math.random()*canvas.width, y:Math.random()*100, w:100, h:50, speed:0.2+Math.random()*0.3});

// monsters
let monsters = [];
for(let i=0;i<10;i++){
  monsters.push({
    x:Math.random()*mapWidth*tileSize,
    y:Math.random()*mapHeight*tileSize,
    size:32, color:'green', hp:100,
    vx:(Math.random()-0.5)*2, vy:(Math.random()-0.5)*2
  });
}

// chests
let chests = [];
for(let i=0;i<10;i++){
  chests.push({
    x:Math.random()*mapWidth*tileSize,
    y:Math.random()*mapHeight*tileSize,
    size:32, opened:false
  });
}

// pets
let pets = [];
for(let i=0;i<2;i++){
  pets.push({x:player.x+Math.random()*50, y:player.y+Math.random()*50, size:16, color:'orange', damage:5});
}

// inventory
let inventoryOpen = false;
let items = []; // item rơi ra

// particle effects
let effects = [];

// key listener
document.addEventListener('keydown', e=>{
  keys[e.key.toLowerCase()] = true;
  if(e.key.toLowerCase() === 'i') inventoryOpen = !inventoryOpen;

  if(e.key.toLowerCase() === 'e'){
    chests.forEach(ch=>{
      let dx = player.x - ch.x;
      let dy = player.y - ch.y;
      if(Math.sqrt(dx*dx+dy*dy)<50 && !ch.opened){
        ch.opened=true;
        // rương rơi ra item
        items.push({x:ch.x, y:ch.y, size:16, color:'gold', type:'coin'});
      }
    });
  }

  if(['1','2','3','4'].includes(e.key)){
    // skill particles trail
    for(let i=0;i<25;i++){
      let angle = Math.random()*Math.PI*2;
      let speed = Math.random()*4;
      effects.push({
        x:player.x, y:player.y,
        vx:Math.cos(angle)*speed,
        vy:Math.sin(angle)*speed,
        radius:5,
        color: e.key==='1'?'cyan': e.key==='2'?'magenta': e.key==='3'?'yellow':'lime',
        life:40,
        trail:[{x:player.x, y:player.y}]
      });
    }
  }
});
document.addEventListener('keyup', e=> keys[e.key.toLowerCase()] = false);

// update
function update(){
  if(keys['w']) player.y -= player.speed;
  if(keys['s']) player.y += player.speed;
  if(keys['a']) player.x -= player.speed;
  if(keys['d']) player.x += player.speed;

  clouds.forEach(c=>{
    c.x += c.speed;
    if(c.x>canvas.width) c.x=-c.w;
  });

  // pets follow player
  pets.forEach(p=>{
    let dx = player.x - p.x;
    let dy = player.y - p.y;
    let dist = Math.sqrt(dx*dx+dy*dy);
    if(dist>20){
      p.x += dx*0.05;
      p.y += dy*0.05;
    }
  });

  // monsters move
  monsters.forEach(m=>{
    m.x += m.vx;
    m.y += m.vy;
    if(m.x<0||m.x>mapWidth*tileSize) m.vx*=-1;
    if(m.y<0||m.y>mapHeight*tileSize) m.vy*=-1;
  });

  // effects
  effects.forEach(e=>{
    e.x += e.vx;
    e.y += e.vy;
    e.radius *= 0.95;
    e.life--;
    // trail
    e.trail.push({x:e.x, y:e.y});
    if(e.trail.length>10) e.trail.shift();
  });
  effects = effects.filter(e=>e.life>0);

  // player pick up items
  items.forEach((it,idx)=>{
    let dx = player.x - it.x;
    let dy = player.y - it.y;
    if(Math.sqrt(dx*dx+dy*dy)<30){
      items.splice(idx,1);
      // add to inventory
      // could extend later
    }
  });
}

// draw
function draw(){
  ctx.clearRect(0,0,canvas.width,canvas.height);

  // map tiles
  for(let y=0;y<mapHeight;y++){
    for(let x=0;x<mapWidth;x++){
      ctx.fillStyle = map[y][x]==='grass'?'#7cfc00':'#1e90ff';
      ctx.fillRect(x*tileSize, y*tileSize, tileSize, tileSize);
    }
  }

  // clouds
  clouds.forEach(c=>{
    ctx.fillStyle='white';
    ctx.beginPath();
    ctx.ellipse(c.x,c.y,c.w,c.h,0,0,Math.PI*2);
    ctx.fill();
  });

  // monsters
  monsters.forEach(m=>{
    ctx.fillStyle=m.color;
    ctx.fillRect(m.x-m.size/2, m.y-m.size/2, m.size, m.size);
  });

  // chests
  chests.forEach(ch=>{
    ctx.fillStyle = ch.opened?'yellow':'brown';
    ctx.fillRect(ch.x-ch.size/2, ch.y-ch.size/2, ch.size, ch.size);
  });

  // pets
  pets.forEach(p=>{
    ctx.fillStyle=p.color;
    ctx.fillRect(p.x-p.size/2, p.y-p.size/2, p.size, p.size);
  });

  // items
  items.forEach(it=>{
    ctx.fillStyle = it.color;
    ctx.fillRect(it.x-it.size/2, it.y-it.size/2, it.size, it.size);
  });

  // player glow + weapon (simple)
  ctx.save();
  ctx.shadowColor='white';
  ctx.shadowBlur=20;
  ctx.fillStyle=player.color;
  ctx.fillRect(player.x-player.size/2, player.y-player.size/2, player.size, player.size);
  // weapon as rectangle
  ctx.fillStyle='silver';
  ctx.fillRect(player.x+player.size/2, player.y-5, 20,10);
  ctx.restore();

  // skill particles
  effects.forEach(e=>{
    ctx.save();
    ctx.globalAlpha = e.life/40;
    // draw trail
    ctx.strokeStyle = e.color;
    ctx.beginPath();
    ctx.moveTo(e.trail[0].x,e.trail[0].y);
    for(let i=1;i<e.trail.length;i++){
      ctx.lineTo(e.trail[i].x, e.trail[i].y);
    }
    ctx.stroke();
    ctx.beginPath();
    ctx.fillStyle = e.color;
    ctx.arc(e.x,e.y,e.radius,0,Math.PI*2);
    ctx.fill();
    ctx.restore();
  });

  // inventory
  if(inventoryOpen){
    ctx.fillStyle='rgba(0,0,0,0.5)';
    ctx.fillRect(50,50,200,300);
    ctx.fillStyle='white';
    ctx.fillText('Inventory',100,70);
  }
}

// loop
function loop(){
  update();
  draw();
  requestAnimationFrame(loop);
}
loop();
</script>
</body>
</html>
<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>Pixel Survival Step 7</title>
<style>
  html, body { margin:0; padding:0; overflow:hidden; background:#87CEEB; }
  canvas { display:block; background:#87CEEB; }
</style>
</head>
<body>
<canvas id="game"></canvas>
<script>
const canvas = document.getElementById('game');
const ctx = canvas.getContext('2d');
canvas.width = window.innerWidth;
canvas.height = window.innerHeight;

// player
let player = { x:500, y:500, size:32, speed:3, color:'red', weapon:'sword' };

// keys
let keys = {};

// map tiles
const tileSize = 64;
const mapWidth = 30;
const mapHeight = 20;
let map = [];
for(let y=0;y<mapHeight;y++){
  let row=[];
  for(let x=0;x<mapWidth;x++) row.push(Math.random()<0.1?'water':'grass');
  map.push(row);
}

// clouds
let clouds = [];
for(let i=0;i<5;i++) clouds.push({x:Math.random()*canvas.width, y:Math.random()*100, w:100, h:50, speed:0.2+Math.random()*0.3});

// monsters
let monsters = [];
for(let i=0;i<10;i++){
  monsters.push({
    x:Math.random()*mapWidth*tileSize,
    y:Math.random()*mapHeight*tileSize,
    size:32, color:'green', hp:100,
    vx:(Math.random()-0.5)*2, vy:(Math.random()-0.5)*2
  });
}

// chests
let chests = [];
for(let i=0;i<10;i++){
  chests.push({x:Math.random()*mapWidth*tileSize, y:Math.random()*mapHeight*tileSize, size:32, opened:false});
});

// pets
let pets = [];
for(let i=0;i<2;i++) pets.push({x:player.x+Math.random()*50, y:player.y+Math.random()*50, size:16, color:'orange', damage:5});

// inventory
let inventoryOpen = false;
let items = [];

// particle effects
let effects = [];

// key listener
document.addEventListener('keydown', e=>{
  keys[e.key.toLowerCase()] = true;
  if(e.key.toLowerCase() === 'i') inventoryOpen = !inventoryOpen;

  if(e.key.toLowerCase() === 'e'){
    chests.forEach(ch=>{
      let dx = player.x - ch.x;
      let dy = player.y - ch.y;
      if(Math.sqrt(dx*dx+dy*dy)<50 && !ch.opened){
        ch.opened=true;
        items.push({x:ch.x, y:ch.y, size:16, color:'gold', type:'coin'});
      }
    });
  }

  if(['1','2','3','4'].includes(e.key)){
    for(let i=0;i<25;i++){
      let angle = Math.random()*Math.PI*2;
      let speed = Math.random()*4+1;
      effects.push({
        x:player.x, y:player.y,
        vx:Math.cos(angle)*speed,
        vy:Math.sin(angle)*speed,
        radius:5,
        color: e.key==='1'?'cyan': e.key==='2'?'magenta': e.key==='3'?'yellow':'lime',
        life:50,
        trail:[{x:player.x, y:player.y}]
      });
    }
  }
});
document.addEventListener('keyup', e=> keys[e.key.toLowerCase()] = false);

// update
function update(){
  if(keys['w']) player.y -= player.speed;
  if(keys['s']) player.y += player.speed;
  if(keys['a']) player.x -= player.speed;
  if(keys['d']) player.x += player.speed;

  clouds.forEach(c=>{c.x+=c.speed;if(c.x>canvas.width)c.x=-c.w;});

  pets.forEach(p=>{
    let dx=player.x-p.x, dy=player.y-p.y;
    if(Math.sqrt(dx*dx+dy*dy)>20){p.x+=dx*0.05; p.y+=dy*0.05;}
  });

  monsters.forEach(m=>{
    m.x+=m.vx; m.y+=m.vy;
    if(m.x<0||m.x>mapWidth*tileSize)m.vx*=-1;
    if(m.y<0||m.y>mapHeight*tileSize)m.vy*=-1;
  });

  effects.forEach(e=>{
    e.x+=e.vx; e.y+=e.vy; e.radius*=0.95; e.life--;
    e.trail.push({x:e.x,y:e.y}); if(e.trail.length>15) e.trail.shift();
  });
  effects = effects.filter(e=>e.life>0);

  items.forEach((it,idx)=>{
    let dx=player.x-it.x, dy=player.y-it.y;
    if(Math.sqrt(dx*dx+dy*dy)<30){ items.splice(idx,1); }
  });
}

// draw
function draw(){
  ctx.clearRect(0,0,canvas.width,canvas.height);

  // map tiles
  for(let y=0;y<mapHeight;y++){
    for(let x=0;x<mapWidth;x++){
      ctx.fillStyle=map[y][x]==='grass'?'#7cfc00':'#1e90ff';
      ctx.fillRect(x*tileSize,y*tileSize,tileSize,tileSize);
    }
  }

  // clouds
  clouds.forEach(c=>{ctx.fillStyle='white';ctx.beginPath();ctx.ellipse(c.x,c.y,c.w,c.h,0,0,Math.PI*2);ctx.fill();});

  // monsters
  monsters.forEach(m=>{ctx.fillStyle=m.color;ctx.fillRect(m.x-m.size/2,m.y-m.size/2,m.size,m.size);});

  // chests
  chests.forEach(ch=>{ctx.fillStyle=ch.opened?'yellow':'brown';ctx.fillRect(ch.x-ch.size/2,ch.y-ch.size/2,ch.size,ch.size);});

  // pets
  pets.forEach(p=>{ctx.fillStyle=p.color;ctx.fillRect(p.x-p.size/2,p.y-p.size/2,p.size,p.size);});

  // items
  items.forEach(it=>{ctx.fillStyle=it.color;ctx.fillRect(it.x-it.size/2,it.y-it.size/2,it.size,it.size);});

  // player glow + weapon
  ctx.save();
  ctx.shadowColor='white'; ctx.shadowBlur=30;
  ctx.fillStyle=player.color;
  ctx.fillRect(player.x-player.size/2,player.y-player.size/2,player.size,player.size);
  ctx.fillStyle='silver';
  ctx.fillRect(player.x+player.size/2,player.y-5,20,10);
  ctx.restore();

  // skill particles with smooth trail + glow
  effects.forEach(e=>{
    ctx.save();
    ctx.globalAlpha=e.life/50;
    ctx.strokeStyle=e.color;
    ctx.lineWidth=2;
    ctx.beginPath();
    ctx.moveTo(e.trail[0].x,e.trail[0].y);
    for(let i=1;i<e.trail.length;i++) ctx.lineTo(e.trail[i].x,e.trail[i].y);
    ctx.stroke();
    ctx.beginPath();
    ctx.fillStyle=e.color;
    ctx.shadowColor=e.color;
    ctx.shadowBlur=15;
    ctx.arc(e.x,e.y,e.radius,0,Math.PI*2);
    ctx.fill();
    ctx.restore();
  });

  // inventory
  if(inventoryOpen){
    ctx.fillStyle='rgba(0,0,0,0.5)';
    ctx.fillRect(50,50,200,300);
    ctx.fillStyle='white';
    ctx.fillText('Inventory',100,70);
  }
}

// loop
function loop(){ update(); draw(); requestAnimationFrame(loop);}
loop();
</script>
</body>
</html>
<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>Pixel Survival Step 8</title>
<style>
  html, body { margin:0; padding:0; overflow:hidden; background:#87CEEB; }
  canvas { display:block; background:#87CEEB; }
</style>
</head>
<body>
<canvas id="game"></canvas>
<script>
const canvas = document.getElementById('game');
const ctx = canvas.getContext('2d');
canvas.width = window.innerWidth;
canvas.height = window.innerHeight;

// player
let player = { x:500, y:500, size:32, speed:3, color:'red', weapon:'sword', hp:100, maxHp:100, mana:50, maxMana:50, gold:0 };

// keys
let keys = {};

// map tiles
const tileSize = 64;
const mapWidth = 30;
const mapHeight = 20;
let map = [];
for(let y=0;y<mapHeight;y++){
  let row=[];
  for(let x=0;x<mapWidth;x++) row.push(Math.random()<0.1?'water':'grass');
  map.push(row);
}

// clouds
let clouds = [];
for(let i=0;i<5;i++) clouds.push({x:Math.random()*canvas.width, y:Math.random()*100, w:100, h:50, speed:0.2+Math.random()*0.3});

// monsters
let monsters = [];
for(let i=0;i<10;i++){
  monsters.push({
    x:Math.random()*mapWidth*tileSize,
    y:Math.random()*mapHeight*tileSize,
    size:32, color:'green', hp:100,
    vx:(Math.random()-0.5)*2, vy:(Math.random()-0.5)*2
  });
}

// chests
let chests = [];
for(let i=0;i<10;i++){
  chests.push({x:Math.random()*mapWidth*tileSize, y:Math.random()*mapHeight*tileSize, size:32, opened:false});
});

// pets
let pets = [];
for(let i=0;i<2;i++) pets.push({x:player.x+Math.random()*50, y:player.y+Math.random()*50, size:16, color:'orange', damage:5});

// inventory
let inventoryOpen = false;
let items = [];

// particle effects
let effects = [];

// key listener
document.addEventListener('keydown', e=>{
  keys[e.key.toLowerCase()] = true;
  if(e.key.toLowerCase() === 'i') inventoryOpen = !inventoryOpen;

  if(e.key.toLowerCase() === 'e'){
    chests.forEach(ch=>{
      let dx = player.x - ch.x;
      let dy = player.y - ch.y;
      if(Math.sqrt(dx*dx+dy*dy)<50 && !ch.opened){
        ch.opened=true;
        items.push({x:ch.x, y:ch.y, size:16, color:'gold', type:'coin'});
      }
    });
  }

  if(['1','2','3','4'].includes(e.key)){
    for(let i=0;i<25;i++){
      let angle = Math.random()*Math.PI*2;
      let speed = Math.random()*4+1;
      effects.push({
        x:player.x, y:player.y,
        vx:Math.cos(angle)*speed,
        vy:Math.sin(angle)*speed,
        radius:5,
        color: e.key==='1'?'cyan': e.key==='2'?'magenta': e.key==='3'?'yellow':'lime',
        life:50,
        trail:[{x:player.x, y:player.y}]
      });
    }
  }
});
document.addEventListener('keyup', e=> keys[e.key.toLowerCase()] = false);

// update
function update(){
  if(keys['w']) player.y -= player.speed;
  if(keys['s']) player.y += player.speed;
  if(keys['a']) player.x -= player.speed;
  if(keys['d']) player.x += player.speed;

  clouds.forEach(c=>{c.x+=c.speed;if(c.x>canvas.width)c.x=-c.w;});

  pets.forEach(p=>{
    let dx=player.x-p.x, dy=player.y-p.y;
    if(Math.sqrt(dx*dx+dy*dy)>20){p.x+=dx*0.05; p.y+=dy*0.05;}
  });

  monsters.forEach(m=>{
    m.x+=m.vx; m.y+=m.vy;
    if(m.x<0||m.x>mapWidth*tileSize)m.vx*=-1;
    if(m.y<0||m.y>mapHeight*tileSize)m.vy*=-1;
  });

  effects.forEach(e=>{
    e.x+=e.vx; e.y+=e.vy; e.radius*=0.95; e.life--;
    e.trail.push({x:e.x,y:e.y}); if(e.trail.length>15) e.trail.shift();
  });
  effects = effects.filter(e=>e.life>0);

  items.forEach((it,idx)=>{
    let dx=player.x-it.x, dy=player.y-it.y;
    if(Math.sqrt(dx*dx+dy*dy)<30){ items.splice(idx,1); player.gold++; }
  });
}

// draw
function draw(){
  ctx.clearRect(0,0,canvas.width,canvas.height);

  // map tiles
  for(let y=0;y<mapHeight;y++){
    for(let x=0;x<mapWidth;x++){
      ctx.fillStyle=map[y][x]==='grass'?'#7cfc00':'#1e90ff';
      ctx.fillRect(x*tileSize,y*tileSize,tileSize,tileSize);
    }
  }

  // clouds
  clouds.forEach(c=>{ctx.fillStyle='white';ctx.beginPath();ctx.ellipse(c.x,c.y,c.w,c.h,0,0,Math.PI*2);ctx.fill();});

  // monsters
  monsters.forEach(m=>{ctx.fillStyle=m.color;ctx.fillRect(m.x-m.size/2,m.y-m.size/2,m.size,m.size);});

  // chests
  chests.forEach(ch=>{ctx.fillStyle=ch.opened?'yellow':'brown';ctx.fillRect(ch.x-ch.size/2,ch.y-ch.size/2,ch.size,ch.size);});

  // pets
  pets.forEach(p=>{ctx.fillStyle=p.color;ctx.fillRect(p.x-p.size/2,p.y-p.size/2,p.size,p.size);});

  // items
  items.forEach(it=>{ctx.fillStyle=it.color;ctx.fillRect(it.x-it.size/2,it.y-it.size/2,it.size,it.size);});

  // player glow + weapon
  ctx.save();
  ctx.shadowColor='white'; ctx.shadowBlur=30;
  ctx.fillStyle=player.color;
  ctx.fillRect(player.x-player.size/2,player.y-player.size/2,player.size,player.size);
  ctx.fillStyle='silver';
  ctx.fillRect(player.x+player.size/2,player.y-5,20,10);
  ctx.restore();

  // skill particles
  effects.forEach(e=>{
    ctx.save();
    ctx.globalAlpha=e.life/50;
    ctx.strokeStyle=e.color;
    ctx.lineWidth=2;
    ctx.beginPath();
    ctx.moveTo(e.trail[0].x,e.trail[0].y);
    for(let i=1;i<e.trail.length;i++) ctx.lineTo(e.trail[i].x,e.trail[i].y);
    ctx.stroke();
    ctx.beginPath();
    ctx.fillStyle=e.color;
    ctx.shadowColor=e.color;
    ctx.shadowBlur=15;
    ctx.arc(e.x,e.y,e.radius,0,Math.PI*2);
    ctx.fill();
    ctx.restore();
  });

  // UI: health bar
  ctx.fillStyle='black'; ctx.fillRect(20,20,200,20);
  ctx.fillStyle='red'; ctx.fillRect(20,20,200*(player.hp/player.maxHp),20);
  ctx.strokeStyle='white'; ctx.strokeRect(20,20,200,20);

  // UI: mana bar
  ctx.fillStyle='black'; ctx.fillRect(20,45,200,10);
  ctx.fillStyle='blue'; ctx.fillRect(20,45,200*(player.mana/player.maxMana),10);
  ctx.strokeStyle='white'; ctx.strokeRect(20,45,200,10);

  // UI: skill bar
  for(let i=0;i<4;i++){
    ctx.fillStyle='gray'; ctx.fillRect(20+i*50, canvas.height-70,40,40);
    ctx.fillStyle='white'; ctx.fillText(i+1, 35+i*50, canvas.height-45);
  }

  // UI: gold
  ctx.fillStyle='yellow';
  ctx.fillText('Gold: '+player.gold, 20, canvas.height-90);

  // inventory
  if(inventoryOpen){
    ctx.fillStyle='rgba(0,0,0,0.5)';
    ctx.fillRect(50,50,200,300);
    ctx.fillStyle='white';
    ctx.fillText('Inventory',100,70);
  }
}

// loop
function loop(){ update(); draw(); requestAnimationFrame(loop);}
loop();
</script>
</body>
</html>
<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>Pixel Survival Step 9</title>
<style>
  html, body { margin:0; padding:0; overflow:hidden; background:#87CEEB; }
  canvas { display:block; background:#87CEEB; }
</style>
</head>
<body>
<canvas id="game"></canvas>
<script>
const canvas = document.getElementById('game');
const ctx = canvas.getContext('2d');
canvas.width = window.innerWidth;
canvas.height = window.innerHeight;

// player
let player = { x:500, y:500, size:32, speed:3, color:'red', weapon:'sword', hp:100, maxHp:100, mana:50, maxMana:50, gold:0 };

// keys
let keys = {};

// map tiles
const tileSize = 64;
const mapWidth = 30;
const mapHeight = 20;
let map = [];
for(let y=0;y<mapHeight;y++){
  let row=[];
  for(let x=0;x<mapWidth;x++) row.push(Math.random()<0.1?'water':'grass');
  map.push(row);
}

// clouds
let clouds = [];
for(let i=0;i<5;i++) clouds.push({x:Math.random()*canvas.width, y:Math.random()*100, w:100, h:50, speed:0.2+Math.random()*0.3});

// monsters
let monsters = [];
for(let i=0;i<10;i++){
  monsters.push({
    x:Math.random()*mapWidth*tileSize,
    y:Math.random()*mapHeight*tileSize,
    size:32, color:'green', hp:50,
    vx:(Math.random()-0.5)*1, vy:(Math.random()-0.5)*1,
    damage:5
  });
}

// chests
let chests = [];
for(let i=0;i<10;i++) chests.push({x:Math.random()*mapWidth*tileSize, y:Math.random()*mapHeight*tileSize, size:32, opened:false});

// pets
let pets = [];
for(let i=0;i<2;i++) pets.push({x:player.x+Math.random()*50, y:player.y+Math.random()*50, size:16, color:'orange', damage:5});

// inventory & items
let inventoryOpen = false;
let items = [];

// particle effects
let effects = [];

// key listener
document.addEventListener('keydown', e=>{
  keys[e.key.toLowerCase()] = true;
  if(e.key.toLowerCase() === 'i') inventoryOpen = !inventoryOpen;

  if(e.key.toLowerCase() === 'e'){
    chests.forEach(ch=>{
      let dx = player.x - ch.x;
      let dy = player.y - ch.y;
      if(Math.sqrt(dx*dx+dy*dy)<50 && !ch.opened){
        ch.opened=true;
        items.push({x:ch.x, y:ch.y, size:16, color:'gold', type:'coin'});
      }
    });
  }

  if(['1','2','3','4'].includes(e.key)){
    for(let i=0;i<25;i++){
      let angle = Math.random()*Math.PI*2;
      let speed = Math.random()*4+1;
      effects.push({
        x:player.x, y:player.y,
        vx:Math.cos(angle)*speed,
        vy:Math.sin(angle)*speed,
        radius:5,
        color: e.key==='1'?'cyan': e.key==='2'?'magenta': e.key==='3'?'yellow':'lime',
        life:50,
        trail:[{x:player.x, y:player.y}]
      });
    }
  }
});
document.addEventListener('keyup', e=> keys[e.key.toLowerCase()] = false);

// update
function update(){
  if(keys['w']) player.y -= player.speed;
  if(keys['s']) player.y += player.speed;
  if(keys['a']) player.x -= player.speed;
  if(keys['d']) player.x += player.speed;

  clouds.forEach(c=>{c.x+=c.speed;if(c.x>canvas.width)c.x=-c.w;});

  // pets follow player and attack monsters
  pets.forEach(p=>{
    let dx=player.x-p.x, dy=player.y-p.y;
    if(Math.sqrt(dx*dx+dy*dy)>20){p.x+=dx*0.05; p.y+=dy*0.05;}
    monsters.forEach((m,idx)=>{
      let mdx = m.x - p.x, mdy = m.y - p.y;
      if(Math.sqrt(mdx*mdx+mdy*mdy)<30){
        m.hp -= p.damage;
        if(m.hp<=0){
          items.push({x:m.x,y:m.y,size:16,color:'gold',type:'coin'});
          monsters.splice(idx,1);
        }
      }
    });
  });

  // monsters move + AI attack
  monsters.forEach(m=>{
    let dx = player.x - m.x, dy = player.y - m.y;
    let dist = Math.sqrt(dx*dx+dy*dy);
    if(dist<150){
      // chase player
      m.vx = dx*0.02; m.vy = dy*0.02;
      if(dist<30){
        player.hp -= m.damage*0.1;
      }
    }else{
      // wander
      m.x += m.vx; m.y += m.vy;
      if(m.x<0||m.x>mapWidth*tileSize)m.vx*=-1;
      if(m.y<0||m.y>mapHeight*tileSize)m.vy*=-1;
    }
  });

  effects.forEach(e=>{
    e.x+=e.vx; e.y+=e.vy; e.radius*=0.95; e.life--;
    e.trail.push({x:e.x,y:e.y}); if(e.trail.length>15) e.trail.shift();
  });
  effects = effects.filter(e=>e.life>0);

  // player pick up items
  items.forEach((it,idx)=>{
    let dx=player.x-it.x, dy=player.y-it.y;
    if(Math.sqrt(dx*dx+dy*dy)<30){ items.splice(idx,1); player.gold++; }
  });
}

// draw
function draw(){
  ctx.clearRect(0,0,canvas.width,canvas.height);

  // map tiles
  for(let y=0;y<mapHeight;y++){
    for(let x=0;x<mapWidth;x++){
      ctx.fillStyle=map[y][x]==='grass'?'#7cfc00':'#1e90ff';
      ctx.fillRect(x*tileSize,y*tileSize,tileSize,tileSize);
    }
  }

  // clouds
  clouds.forEach(c=>{ctx.fillStyle='white';ctx.beginPath();ctx.ellipse(c.x,c.y,c.w,c.h,0,0,Math.PI*2);ctx.fill();});

  // monsters
  monsters.forEach(m=>{ctx.fillStyle=m.color;ctx.fillRect(m.x-m.size/2,m.y-m.size/2,m.size,m.size);});

  // chests
  chests.forEach(ch=>{ctx.fillStyle=ch.opened?'yellow':'brown';ctx.fillRect(ch.x-ch.size/2,ch.y-ch.size/2,ch.size,ch.size);});

  // pets
  pets.forEach(p=>{ctx.fillStyle=p.color;ctx.fillRect(p.x-p.size/2,p.y-p.size/2,p.size,p.size);});

  // items
  items.forEach(it=>{ctx.fillStyle=it.color;ctx.fillRect(it.x-it.size/2,it.y-it.size/2,it.size,it.size);});

  // player glow + weapon
  ctx.save();
  ctx.shadowColor='white'; ctx.shadowBlur=30;
  ctx.fillStyle=player.color;
  ctx.fillRect(player.x-player.size/2,player.y-player.size/2,player.size,player.size);
  ctx.fillStyle='silver';
  ctx.fillRect(player.x+player.size/2,player.y-5,20,10);
  ctx.restore();

  // skill particles
  effects.forEach(e=>{
    ctx.save();
    ctx.globalAlpha=e.life/50;
    ctx.strokeStyle=e.color;
    ctx.lineWidth=2;
    ctx.beginPath();
    ctx.moveTo(e.trail[0].x,e.trail[0].y);
    for(let i=1;i<e.trail.length;i++) ctx.lineTo(e.trail[i].x,e.trail[i].y);
    ctx.stroke();
    ctx.beginPath();
    ctx.fillStyle=e.color;
    ctx.shadowColor=e.color;
    ctx.shadowBlur=15;
    ctx.arc(e.x,e.y,e.radius,0,Math.PI*2);
    ctx.fill();
    ctx.restore();
  });

  // UI: health & mana bar
  ctx.fillStyle='black'; ctx.fillRect(20,20,200,20);
  ctx.fillStyle='red'; ctx.fillRect(20,20,200*(player.hp/player.maxHp),20);
  ctx.strokeStyle='white'; ctx.strokeRect(20,20,200,20);

  ctx.fillStyle='black'; ctx.fillRect(20,45,200,10);
  ctx.fillStyle='blue'; ctx.fillRect(20,45,200*(player.mana/player.maxMana),10);
  ctx.strokeStyle='white'; ctx.strokeRect(20,45,200,10);

  // UI: skill bar
  for(let i=0;i<4;i++){
    ctx.fillStyle='gray'; ctx.fillRect(20+i*50, canvas.height-70,40,40);
    ctx.fillStyle='white'; ctx.fillText(i+1, 35+i*50, canvas.height-45);
  }

  // UI: gold
  ctx.fillStyle='yellow';
  ctx.fillText('Gold: '+player.gold, 20, canvas.height-90);

  // inventory
  if(inventoryOpen){
    ctx.fillStyle='rgba(0,0,0,0.5)';
    ctx.fillRect(50,50,200,300);
    ctx.fillStyle='white';
    ctx.fillText('Inventory',100,70);
  }
}

// loop
function loop(){ update(); draw(); requestAnimationFrame(loop);}
loop();
</script>
</body>
</html>
<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>Pixel Survival Step 10</title>
<style>
html, body {margin:0; padding:0; overflow:hidden; background:#87CEEB;}
canvas {display:block; background:#87CEEB;}
</style>
</head>
<body>
<canvas id="game"></canvas>
<script>
const canvas=document.getElementById('game');
const ctx=canvas.getContext('2d');
canvas.width=window.innerWidth;
canvas.height=window.innerHeight;

// player
let player={x:500,y:500,size:32,speed:3,color:'red',weapon:'sword',hp:100,maxHp:100,mana:50,maxMana:50,gold:0};
// keys
let keys={};
// map
const tileSize=64,mapWidth=50,mapHeight=30;
let map=[];
for(let y=0;y<mapHeight;y++){
  let row=[];
  for(let x=0;x<mapWidth;x++) row.push(Math.random()<0.1?'water':'grass');
  map.push(row);
}

// clouds
let clouds=[];
for(let i=0;i<10;i++) clouds.push({x:Math.random()*canvas.width,y:Math.random()*100,w:100,h:50,speed:0.2+Math.random()*0.5});

// monsters
let monsters=[];
function spawnMonsters(n){
  for(let i=0;i<n;i++){
    monsters.push({x:Math.random()*mapWidth*tileSize,y:Math.random()*mapHeight*tileSize,size:32,color:'green',hp:50,vx:(Math.random()-0.5)*1,vy:(Math.random()-0.5)*1,damage:5});
  }
}
spawnMonsters(20);

// boss
let boss={x:canvas.width/2,y:canvas.height/2,size:64,color:'purple',hp:500,maxHp:500,damage:20,active:false};

// chests & items
let chests=[],items=[];
for(let i=0;i<15;i++) chests.push({x:Math.random()*mapWidth*tileSize,y:Math.random()*mapHeight*tileSize,size:32,opened:false});

// pets
let pets=[];
for(let i=0;i<2;i++) pets.push({x:player.x+Math.random()*50,y:player.y+Math.random()*50,size:16,color:'orange',damage:5});

// effects
let effects=[];

// key listener
document.addEventListener('keydown',e=>{
  keys[e.key.toLowerCase()]=true;
  if(e.key.toLowerCase()==='i') inventoryOpen=!inventoryOpen;
  if(e.key.toLowerCase()==='e'){
    chests.forEach(ch=>{
      let dx=player.x-ch.x,dy=player.y-ch.y;
      if(Math.sqrt(dx*dx+dy*dy)<50&&!ch.opened){ch.opened=true; items.push({x:ch.x,y:ch.y,size:16,color:'gold',type:'coin'});}
    });
  }
  if(['1','2','3','4'].includes(e.key)){
    for(let i=0;i<30;i++){
      let angle=Math.random()*Math.PI*2,speed=Math.random()*5+1;
      effects.push({x:player.x,y:player.y,vx:Math.cos(angle)*speed,vy:Math.sin(angle)*speed,radius:5,color:e.key==='1'?'cyan':e.key==='2'?'magenta':e.key==='3'?'yellow':'lime',life:60,trail:[{x:player.x,y:player.y}]});
    }
  }
});
document.addEventListener('keyup',e=>keys[e.key.toLowerCase()]=false);

// inventory
let inventoryOpen=false;

// update
function update(){
  if(keys['w']) player.y-=player.speed;
  if(keys['s']) player.y+=player.speed;
  if(keys['a']) player.x-=player.speed;
  if(keys['d']) player.x+=player.speed;

  clouds.forEach(c=>{c.x+=c.speed;if(c.x>canvas.width)c.x=-c.w;});
  // pets follow + attack monsters
  pets.forEach(p=>{
    let dx=player.x-p.x,dy=player.y-p.y;
    if(Math.sqrt(dx*dx+dy*dy)>20){p.x+=dx*0.05; p.y+=dy*0.05;}
    monsters.forEach((m,idx)=>{
      let mdx=m.x-p.x,mdy=m.y-p.y;
      if(Math.sqrt(mdx*mdx+mdy*mdy)<30){ m.hp-=p.damage; if(m.hp<=0){items.push({x:m.x,y:m.y,size:16,color:'gold',type:'coin'}); monsters.splice(idx,1);} }
    });
  });

  // monsters AI + attack
  monsters.forEach(m=>{
    let dx=player.x-m.x,dy=player.y-m.y,dist=Math.sqrt(dx*dx+dy*dy);
    if(dist<150){ m.vx=dx*0.02;m.vy=dy*0.02; if(dist<30) player.hp-=m.damage*0.05;} 
    else{ m.x+=m.vx;m.y+=m.vy; if(m.x<0||m.x>mapWidth*tileSize)m.vx*=-1;if(m.y<0||m.y>mapHeight*tileSize)m.vy*=-1;}
  });

  // boss AI
  if(!boss.active && player.x>canvas.width/2-200 && player.x<canvas.width/2+200 && player.y>canvas.height/2-200 && player.y<canvas.height/2+200) boss.active=true;
  if(boss.active){
    let dx=player.x-boss.x,dy=player.y-boss.y;
    let dist=Math.sqrt(dx*dx+dy*dy);
    boss.x+=dx*0.01; boss.y+=dy*0.01;
    if(dist<60) player.hp-=boss.damage*0.05;
  }

  effects.forEach(e=>{e.x+=e.vx;e.y+=e.vy;e.radius*=0.95;e.life--; e.trail.push({x:e.x,y:e.y}); if(e.trail.length>15)e.trail.shift();});
  effects=effects.filter(e=>e.life>0);

  // pick items
  items.forEach((it,idx)=>{let dx=player.x-it.x,dy=player.y-it.y;if(Math.sqrt(dx*dx+dy*dy)<30){items.splice(idx,1);player.gold++;}});
}

// draw
function draw(){
  ctx.clearRect(0,0,canvas.width,canvas.height);

  // map
  for(let y=0;y<mapHeight;y++){for(let x=0;x<mapWidth;x++){ctx.fillStyle=map[y][x]==='grass'?'#7cfc00':'#1e90ff';ctx.fillRect(x*tileSize,y*tileSize,tileSize,tileSize);}}

  // clouds
  clouds.forEach(c=>{ctx.fillStyle='white';ctx.beginPath();ctx.ellipse(c.x,c.y,c.w,c.h,0,0,Math.PI*2);ctx.fill();});

  // monsters
  monsters.forEach(m=>{ctx.fillStyle=m.color;ctx.fillRect(m.x-m.size/2,m.y-m.size/2,m.size,m.size);});

  // boss
  if(boss.active){ctx.fillStyle=boss.color;ctx.fillRect(boss.x-boss.size/2,boss.y-boss.size/2,boss.size,boss.size);}

  // chests
  chests.forEach(ch=>{ctx.fillStyle=ch.opened?'yellow':'brown';ctx.fillRect(ch.x-ch.size/2,ch.y-ch.size/2,ch.size,ch.size);});

  // pets
  pets.forEach(p=>{ctx.fillStyle=p.color;ctx.fillRect(p.x-p.size/2,p.y-p.size/2,p.size,p.size);});

  // items
  items.forEach(it=>{ctx.fillStyle=it.color;ctx.fillRect(it.x-it.size/2,it.y-it.size/2,it.size,it.size);});

  // player
  ctx.save(); ctx.shadowColor='white'; ctx.shadowBlur=30; ctx.fillStyle=player.color; ctx.fillRect(player.x-player.size/2,player.y-player.size/2,player.size,player.size);ctx.fillStyle='silver';ctx.fillRect(player.x+player.size/2,player.y-5,20,10);ctx.restore();

  // skill particles
  effects.forEach(e=>{ctx.save(); ctx.globalAlpha=e.life/60; ctx.strokeStyle=e.color; ctx.lineWidth=2; ctx.beginPath(); ctx.moveTo(e.trail[0].x,e.trail[0].y); for(let i=1;i<e.trail.length;i++) ctx.lineTo(e.trail[i].x,e.trail[i].y); ctx.stroke(); ctx.beginPath(); ctx.fillStyle=e.color; ctx.shadowColor=e.color; ctx.shadowBlur=20; ctx.arc(e.x,e.y,e.radius,0,Math.PI*2); ctx.fill(); ctx.restore(); });

  // UI
  ctx.fillStyle='black'; ctx.fillRect(20,20,200,20); ctx.fillStyle='red'; ctx.fillRect(20,20,200*(player.hp/player.maxHp),20); ctx.strokeStyle='white'; ctx.strokeRect(20,20,200,20);
  ctx.fillStyle='black'; ctx.fillRect(20,45,200,10); ctx.fillStyle='blue'; ctx.fillRect(20,45,200*(player.mana/player.maxMana),10); ctx.strokeStyle='white'; ctx.strokeRect(20,45,200,10);

  for(let i=0;i<4;i++){ctx.fillStyle='gray'; ctx.fillRect(20+i*50, canvas.height-70,40,40); ctx.fillStyle='white'; ctx.fillText(i+1,35+i*50,canvas.height-45);}
  ctx.fillStyle='yellow'; ctx.fillText('Gold: '+player.gold,20,canvas.height-90);

  if(inventoryOpen){ctx.fillStyle='rgba(0,0,0,0.5)'; ctx.fillRect(50,50,200,300); ctx.fillStyle='white'; ctx
<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>Pixel Survival Step 11</title>
<style>
html, body { margin:0; padding:0; overflow:hidden; background:#87CEEB; }
canvas { display:block; background:#87CEEB; }
</style>
</head>
<body>
<canvas id="game"></canvas>
<script>
const canvas = document.getElementById('game');
const ctx = canvas.getContext('2d');
canvas.width = window.innerWidth;
canvas.height = window.innerHeight;

// player
let player = {x:500,y:500,size:32,speed:3,color:'red',weapon:'sword',hp:100,maxHp:100,mana:50,maxMana:50,gold:0,exp:0,level:1};

// keys
let keys = {};

// map
const tileSize = 64, mapWidth = 70, mapHeight = 50;
let map = [];
for(let y=0;y<mapHeight;y++){
  let row = [];
  for(let x=0;x<mapWidth;x++){
    let r = Math.random();
    if(r<0.05) row.push('water');
    else if(r<0.15) row.push('sand');
    else if(r<0.3) row.push('mountain');
    else row.push('grass');
  }
  map.push(row);
}

// clouds
let clouds = [];
for(let i=0;i<15;i++) clouds.push({x:Math.random()*canvas.width,y:Math.random()*150,w:100,h:50,speed:0.2+Math.random()*0.5});

// monsters
let monsters = [];
function spawnMonsters(n){
  for(let i=0;i<n;i++){
    let color = Math.random()<0.1?'red':'green';
    let size = color==='red'?48:32;
    monsters.push({x:Math.random()*mapWidth*tileSize,y:Math.random()*mapHeight*tileSize,size:size,color:color,hp:size*2,vx:(Math.random()-0.5)*1,vy:(Math.random()-0.5)*1,damage:size/8});
  }
}
spawnMonsters(50);

// bosses
let bosses = [];
function spawnBoss(){
  let types = ['purple','darkred','gold'];
  let type = types[Math.floor(Math.random()*types.length)];
  bosses.push({x:Math.random()*mapWidth*tileSize,y:Math.random()*mapHeight*tileSize,size:64,color:type,hp:500,damage:20,active:true});
}

// chests & items
let chests=[], items=[];
for(let i=0;i<25;i++) chests.push({x:Math.random()*mapWidth*tileSize,y:Math.random()*mapHeight*tileSize,size:32,opened:false});

// pets
let pets=[];
for(let i=0;i<3;i++) pets.push({x:player.x+Math.random()*50,y:player.y+Math.random()*50,size:16,color:'orange',damage:5,level:1});

// effects
let effects=[];

// inventory
let inventoryOpen=false;

// key listener
document.addEventListener('keydown',e=>{
  keys[e.key.toLowerCase()]=true;
  if(e.key.toLowerCase()==='i') inventoryOpen=!inventoryOpen;
  if(e.key.toLowerCase()==='e'){
    chests.forEach(ch=>{
      let dx=player.x-ch.x,dy=player.y-ch.y;
      if(Math.sqrt(dx*dx+dy*dy)<50&&!ch.opened){ch.opened=true; 
        let r = Math.random();
        if(r<0.5) items.push({x:ch.x,y:ch.y,size:16,color:'gold',type:'coin'});
        else items.push({x:ch.x,y:ch.y,size:16,color:'cyan',type:'potion'});
      }
    });
  }
  if(['1','2','3','4'].includes(e.key)){
    for(let i=0;i<40;i++){
      let angle=Math.random()*Math.PI*2,speed=Math.random()*5+1;
      let color=e.key==='1'?'cyan':e.key==='2'?'magenta':e.key==='3'?'yellow':'lime';
      effects.push({x:player.x,y:player.y,vx:Math.cos(angle)*speed,vy:Math.sin(angle)*speed,radius:5,color:color,life:60,trail:[{x:player.x,y:player.y}]});
    }
  }
});
document.addEventListener('keyup',e=>keys[e.key.toLowerCase()]=false);

// update
function update(){
  if(keys['w']) player.y-=player.speed;
  if(keys['s']) player.y+=player.speed;
  if(keys['a']) player.x-=player.speed;
  if(keys['d']) player.x+=player.speed;

  clouds.forEach(c=>{c.x+=c.speed;if(c.x>canvas.width)c.x=-c.w;});

  // pets follow + attack monsters
  pets.forEach(p=>{
    let dx=player.x-p.x,dy=player.y-p.y;
    if(Math.sqrt(dx*dx+dy*dy)>20){p.x+=dx*0.05;p.y+=dy*0.05;}
    monsters.forEach((m,idx)=>{
      let mdx=m.x-p.x,mdy=m.y-p.y;
      if(Math.sqrt(mdx*mdx+mdy*mdy)<30){ m.hp-=p.damage; if(m.hp<=0){items.push({x:m.x,y:m.y,size:16,color:'gold',type:'coin'}); monsters.splice(idx,1);} }
    });
  });

  // monsters AI
  monsters.forEach(m=>{
    let dx=player.x-m.x,dy=player.y-m.y,dist=Math.sqrt(dx*dx+dy*dy);
    if(dist<150){ m.vx=dx*0.02;m.vy=dy*0.02; if(dist<30) player.hp-=m.damage*0.05;} 
    else{ m.x+=m.vx;m.y+=m.vy; if(m.x<0||m.x>mapWidth*tileSize)m.vx*=-1;if(m.y<0||m.y>mapHeight*tileSize)m.vy*=-1;}
  });

  // bosses AI
  bosses.forEach((b,idx)=>{
    let dx=player.x-b.x,dy=player.y-b.y,dist=Math.sqrt(dx*dx+dy*dy);
    if(dist<200){ b.x+=dx*0.01; b.y+=dy*0.01; if(dist<60) player.hp-=b.damage*0.05; }
    if(b.hp<=0){items.push({x:b.x,y:b.y,size:20,color:'gold',type:'rare'}); bosses.splice(idx,1);}
  });

  // effects update
  effects.forEach(e=>{e.x+=e.vx;e.y+=e.vy;e.radius*=0.95;e.life--; e.trail.push({x:e.x,y:e.y}); if(e.trail.length>20) e.trail.shift();});
  effects=effects.filter(e=>e.life>0);

  // pick items
  items.forEach((it,idx)=>{let dx=player.x-it.x,dy=player.y-it.y;if(Math.sqrt(dx*dx+dy*dy)<30){items.splice(idx,1);player.gold++;}});
}

// draw
function draw(){
  ctx.clearRect(0,0,canvas.width,canvas.height);

  // map tiles
  for(let y=0;y<mapHeight;y++){for(let x=0;x<mapWidth;x++){let col='';switch(map[y][x]){case 'grass':col='#7cfc00';break;case 'water':col='#1e90ff';break;case 'sand':col='#f4d27a';break;case 'mountain':col='#8b8b8b';break;}ctx.fillStyle=col;ctx.fillRect(x*tileSize,y*tileSize,tileSize,tileSize);}}

  // clouds
  clouds.forEach(c=>{ctx.fillStyle='white';ctx.beginPath();ctx.ellipse(c.x,c.y,c.w,c.h,0,0,Math.PI*2);ctx.fill();});

  // monsters
  monsters.forEach(m=>{ctx.fillStyle=m.color;ctx.fillRect(m.x-m.size/2,m.y-m.size/2,m.size,m.size);});

  // bosses
  bosses.forEach(b=>{ctx.fillStyle=b.color;ctx.fillRect(b.x-b.size/2,b.y-b.size/2,b.size,b.size);});

  // chests
  chests.forEach(ch=>{ctx.fillStyle=ch.opened?'yellow':'brown';ctx.fillRect(ch.x-ch.size/2,ch.y-ch.size/2,ch.size,ch.size);});

  // pets
  pets.forEach(p=>{ctx.fillStyle=p.color;ctx.fillRect(p.x-p.size/2,p.y-p.size/2,p.size,p.size);});

  // items
  items.forEach(it=>{ctx.fillStyle=it.color;ctx.fillRect(it.x-it.size/2,it.y-it.size/2,it.size,it.size);});

  // player
  ctx.save(); ctx.shadowColor='white'; ctx.shadowBlur=30; ctx.fillStyle=player.color; ctx.fillRect(player.x-player.size/2,player.y-player.size/2,player.size,player.size); ctx.fillStyle='silver'; ctx.fillRect(player.x+player.size/2,player.y-5,20,10); ctx.restore();

  // skill particles
  effects.forEach(e=>{ctx.save(); ctx.globalAlpha=e.life/60; ctx.strokeStyle=e.color; ctx.lineWidth=2; ctx.beginPath(); ctx.moveTo(e.trail[0].x,e.trail[0].y); for(let i=1;i<e.trail.length;i++) ctx.lineTo(e.trail[i].x,e.trail[i].y); ctx.stroke(); ctx.beginPath(); ctx.fillStyle=e.color; ctx.shadowColor=e.color; ctx.shadowBlur=20; ctx.arc(e.x,e.y,e.radius,0,Math.PI*2); ctx.fill(); ctx.restore(); });

  // UI
  ctx.fillStyle='black'; ctx.fillRect(20,20,200,20); ctx.fillStyle='red'; ctx.fillRect(20,20,200*(player.hp/player.maxHp),20); ctx.strokeStyle='white'; ctx.strokeRect(20,20,200,20);
  ctx.fillStyle='black'; ctx.fillRect(20,45,200,10); ctx.fillStyle='blue'; ctx.fillRect(20,45,200*(player.mana/player.maxMana),10); ctx.strokeStyle='white'; ctx.strokeRect(20,45,200,10);
  for(let i=0;i<4;i++){ctx.fillStyle='gray'; ctx.fillRect(20+i*50, canvas.height-70,40,40); ctx.fillStyle='white'; ctx.fillText(i+1,35+i*50,canvas.height-45);}
  ctx.fillStyle='yellow'; ctx.fillText('Gold: '+player.gold,20,canvas.height-90);

  if(inventoryOpen){ctx.fillStyle='rgba(0,0,0,0.5)'; ctx.fillRect(50,50,200,300); ctx.fillStyle='white'; ctx.fillText('Inventory',100,70);}
}

// loop
function loop(){ update(); draw(); requestAnimationFrame(loop);}
loop();
</script>
</body>
</html>
